// Copyright 2023 DreamWorks Animation LLC
// SPDX-License-Identifier: Apache-2.0

/// @file WireframeMap.cc

/*
 * The code implements wireframe shader. To draw wireframe around a shape
 * (triangles or quads), we sample points on the shape and draw a point if
 * it sits within the given line width of wireframe. Therefore we first
 * estimate the pixel width by computing dpdx and dpdy and then compute the
 * wireframe line width in raster space. Then we compute the area generated
 * by a line as if the line width were equal to the distance between the
 * point and the edge, and compare to the total area covered by a line
 * generated by the given line width. If the former is smaller than the latter,
 * the point locates within the wireframe.
 */

#include "attributes.cc"
#include "WireframeMap_ispc_stubs.h"

#include <moonray/rendering/shading/MapApi.h>
#include <scene_rdl2/common/math/Color.h>
#include <scene_rdl2/scene/rdl2/rdl2.h>

#include <random>
#include <string>
#include <vector>
#include <math.h>

using namespace moonray;
using namespace scene_rdl2::math;
using namespace moonray::shading;

//---------------------------------------------------------------------------

RDL2_DSO_CLASS_BEGIN(WireframeMap, Map)

public:
    WireframeMap(const SceneClass& sceneClass, const std::string& name);
    ~WireframeMap();
    virtual void update();

private:
    static void sample(const Map* self, moonray::shading::TLState *tls,
                       const moonray::shading::State& state, Color* sample);

    ispc::WireframeMap mData;

RDL2_DSO_CLASS_END(WireframeMap)

//---------------------------------------------------------------------------

WireframeMap::WireframeMap(const SceneClass& sceneClass, const std::string& name) :
    Parent(sceneClass, name)
{
    mSampleFunc = WireframeMap::sample;
    mSampleFuncv = (SampleFuncv) ispc::WireframeMap_getSampleFunc();
}

WireframeMap::~WireframeMap()
{
}

void
WireframeMap::update()
{
    mRequiredAttributes.clear();
    mRequiredAttributes.push_back(StandardAttributes::sNumPolyVertices);
    mRequiredAttributes.push_back(StandardAttributes::sPolyVertexType);
    mOptionalAttributes.clear();
    for (size_t i = 0; i < StandardAttributes::MAX_NUM_POLYVERTICES; ++i) {
        mOptionalAttributes.push_back(StandardAttributes::sPolyVertices[i]);
    }

    mData.mNumPolyVerticesIndx = StandardAttributes::sNumPolyVertices.getIndex();
    mData.mPolyVertexTypeIndx = StandardAttributes::sPolyVertexType.getIndex();
    for (size_t i = 0; i < StandardAttributes::MAX_NUM_POLYVERTICES; ++i) {
        mData.mPolyVertices[i] = StandardAttributes::sPolyVertices[i].getIndex();
    }
}

void
WireframeMap::sample(const Map* self, moonray::shading::TLState *tls,
        const moonray::shading::State& state, Color* sample)
{
    const WireframeMap* me = static_cast<const WireframeMap*>(self);

    // return lineColor if the intersection point is on a polygon edge, fillColor if not
    const Color lineColor = me->get(attrLineColor);
    const Color fillColor = me->get(attrFillColor);

    // what type of data is in our poly vertex array?
    const int ptype = state.getAttribute(StandardAttributes::sPolyVertexType);

    if (ptype == StandardAttributes::POLYVERTEX_TYPE_UNKNOWN) {
        // well if you don't know, then neither do we.
        *sample = fillColor;
        return;
    }

    if (ptype == StandardAttributes::POLYVERTEX_TYPE_CUBIC_SPLINE ||
        ptype == StandardAttributes::POLYVERTEX_TYPE_LINE) {
        // curves are basically all edge.  the main issue is curve thickness
        // that will not in general match the desired raster pixel width.
        // for now, a hit on a curve is a hit on the edge.
        *sample = lineColor;
        return;
    }

    MNRY_ASSERT(ptype == StandardAttributes::POLYVERTEX_TYPE_POLYGON);

    const bool isRaster = me->get(attrRaster);
    const float lineWidth = me->get(attrLineWidth);
    const float lineThickness = lineWidth * .5;

    const int numPolyVertices = state.getAttribute(StandardAttributes::sNumPolyVertices);

    if (numPolyVertices) {
        // estimate pixel width in render space at point P
        //
        //        pwX
        //    +--------+ P + dpdx
        //    |       /
        //    |      /
        //    |     /
        //    |    /
        //    |   /
        //    |  /
        //    | /
        //    +
        //    P
        const Vec3f dpds = state.getdPds();
        const Vec3f dpdt = state.getdPdt();
        const float dsdx = state.getdSdx();
        const float dsdy = state.getdSdy();
        const float dtdx = state.getdTdx();
        const float dtdy = state.getdTdy();

        const Vec3f dpdx = dpds * dsdx + dpdt * dtdx;
        const Vec3f dpdy = dpds * dsdy + dpdt * dtdy;
        const Vec3f I = normalize(state.getP());
        const float pwXSq = lengthSqr(dpdx - dot(I, dpdx) * I);
        const float pwYSq = lengthSqr(dpdy - dot(I, dpdy) * I);

        // we want to consider just half the estimated pixel width for this
        // polygon, neighboring polygons will account for the other half
        //    (pwX / 2) * (pwX / 2) = pwXSq * .25
        //    (pwY / 2) * (PwY / 2) = pwYSq * .25
        // and then we want to average these values
        // to get our final pwSq estimate that we'll use for comparisons
        //    (pwXSq * .25 + pwYSq * .25) * .5

        const float pw = (scene_rdl2::math::sqrt(pwXSq) +
                          scene_rdl2::math::sqrt(pwYSq)) * .5f;
        // When "lineWidth" is specified in "world space",
        // renderSpaceLineThickness is equal to lineWidth * .75
        // We use the constant .75 to match the results of Arnold's wireframe shader
        float renderSpaceLineThickness = lineThickness + lineThickness * 0.5;
        // When "lineWidth" is in raster space (num of pixels), then
        // renderSpaceLineThickness is equal to pw * lineWidth.
        if (isRaster) renderSpaceLineThickness = pw * lineWidth;
        float renderSpaceLineThicknessSq = renderSpaceLineThickness * renderSpaceLineThickness;

        // loop over vertices looking for a nearby edge
        for (int i1 = 0; i1 < numPolyVertices; ++i1) {
            int i0 = i1? i1 - 1 : numPolyVertices - 1;

            const Vec3f p0 = state.getAttribute(StandardAttributes::sPolyVertices[i0]);
            const Vec3f p1 = state.getAttribute(StandardAttributes::sPolyVertices[i1]);

            const Vec3f edge = p1 - p0;
            const Vec3f dir = state.getP() - p0;

            const float areaASq = lengthSqr(cross(edge, dir));
            // "B" is the triangle (p1, p, p0), which is half of "A"
            //      areaA = areaB * 2
            //      areaAsq = areaBSq * 4
            //
            // "d" is the height of B, and more importantly, the
            // closest distance from the intersection point p, to the edge.
            //    areaB   = d * length(edge) / 2
            //    areaBSq = dSq * lengthSqr(edge) / 4
            //    areaASq = dSq * lengthSqr(edge)
            //
            // in the case where p is on the edge, d must be within line thickness
            // or d < renderSpaceLineThickness
            if (areaASq < (renderSpaceLineThicknessSq * lengthSqr(edge))) {
                *sample = lineColor;
                return; // all done
            }
        }
    }
    *sample = fillColor;
    return;
}

//---------------------------------------------------------------------------

